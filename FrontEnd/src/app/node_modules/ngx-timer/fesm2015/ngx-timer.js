import { CommonModule } from '@angular/common';
import { Injectable, Component, NgModule, Input, EventEmitter, defineInjectable } from '@angular/core';
import { Observable, interval } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CountupTimerService {
    constructor() {
        //Init
        this.timerValue = {
            seconds: '00',
            mins: '00',
            hours: '00',
        };
        this.isTimerStart = false;
        this.totalSeconds = 0;
        this.currentOperationId = 0;
        //start timer
        this.startTimer = (/**
         * @param {?=} startTime
         * @return {?}
         */
        (startTime) => {
            if (startTime) {
                /** @type {?} */
                let currentDate = new Date();
                /** @type {?} */
                let startedTime = new Date(startTime);
                this.totalSeconds = Math.round((currentDate.getTime() - startedTime.getTime()) / 1000);
            }
            this.isTimerStart = true;
            return true;
        });
        //end timer
        this.pauseTimer = (/**
         * @param {?=} startTime
         * @param {?=} endTime
         * @return {?}
         */
        (startTime, endTime) => {
            if (startTime && endTime) {
                /** @type {?} */
                let endedDate = new Date(endTime);
                /** @type {?} */
                let startedTime = new Date(startTime);
                this.totalSeconds = Math.round((endedDate.getTime() - startedTime.getTime()) / 1000);
            }
            this.isTimerStart = false;
            return false;
        });
        //reset Timer
        this.stopTimer = (/**
         * @return {?}
         */
        () => {
            this.isTimerStart = false;
            this.totalSeconds = 0;
        });
        //get timer value Obj
        this.getTimerValue = (/**
         * @return {?}
         */
        () => {
            return new Observable((/**
             * @param {?} obs
             * @return {?}
             */
            obs => {
                if (this.intervalSubscription) {
                    this.intervalSubscription.unsubscribe();
                }
                this.intervalSubscription = this.interval.subscribe((/**
                 * @param {?} int
                 * @return {?}
                 */
                int => {
                    if (this.isTimerStart) {
                        ++this.totalSeconds;
                        this.timerValue.seconds = this.setTimervalue(this.totalSeconds % 60);
                        /** @type {?} */
                        let totalSecondsForMinutes = 0;
                        totalSecondsForMinutes = (Math.trunc(this.totalSeconds / 60) >= 60) ? (this.totalSeconds / 60) % 60 : this.totalSeconds / 60;
                        this.timerValue.mins = this.setTimervalue(Math.trunc(totalSecondsForMinutes));
                        this.timerValue.hours = this.setTimervalue(Math.trunc(this.totalSeconds / 3600));
                        obs.next(this.timerValue);
                        obs.complete();
                    }
                    else {
                        if (this.totalSeconds > 0) {
                            this.timerValue.seconds = this.setTimervalue(this.totalSeconds % 60);
                            /** @type {?} */
                            let totalSecondsForMinutes = 0;
                            totalSecondsForMinutes = (Math.trunc(this.totalSeconds / 60) >= 60) ? (this.totalSeconds / 60) % 60 : this.totalSeconds / 60;
                            this.timerValue.mins = this.setTimervalue(Math.trunc(totalSecondsForMinutes));
                            this.timerValue.hours = this.setTimervalue(Math.trunc(this.totalSeconds / 3600));
                        }
                        else {
                            this.timerValue.hours = "00";
                            this.timerValue.mins = "00";
                            this.timerValue.seconds = "00";
                        }
                        obs.next(this.timerValue);
                        obs.complete();
                    }
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                error => {
                    obs.error(error);
                    obs.complete();
                }));
            }));
        });
        //set timer value
        this.setTimervalue = (/**
         * @param {?} val
         * @return {?}
         */
        (val) => {
            /** @type {?} */
            let valString = val + "";
            return (valString.length < 2) ? "0" + valString : valString;
        });
        this.interval = interval(1000);
    }
}
CountupTimerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CountupTimerService.ctorParameters = () => [];
/** @nocollapse */ CountupTimerService.ngInjectableDef = defineInjectable({ factory: function CountupTimerService_Factory() { return new CountupTimerService(); }, token: CountupTimerService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class countUpTimerConfigModel {
}
class timerTexts {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CountupTimerComponent {
    /**
     * @param {?} countupTimerService
     */
    constructor(countupTimerService) {
        this.countupTimerService = countupTimerService;
        //Init
        this.timerObj = {};
        //get timer value
        this.getTimerValue = (/**
         * @return {?}
         */
        () => {
            this.timerSubscription = this.countupTimerService.getTimerValue().subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => {
                this.timerObj = Object.assign(res);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                console.log(error);
                console.log('Failed to get timer value');
            }));
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.getTimerValue();
        this.timerConfig = new countUpTimerConfigModel();
        this.timerTextConfig = new timerTexts();
        this.timerConfig = this.countUpTimerConfig ? Object.assign(this.countUpTimerConfig) : null;
        this.timerTextConfig = this.countUpTimerConfig && this.countUpTimerConfig.timerTexts ? Object.assign(this.countUpTimerConfig.timerTexts) : null;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.timerSubscription.unsubscribe();
    }
}
CountupTimerComponent.decorators = [
    { type: Component, args: [{
                selector: 'countup-timer',
                template: "<div [class]=\"timerConfig?.timerClass ? timerConfig.timerClass : ''\">\n  <span>{{timerObj.hours}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.hourText ? timerTextConfig.hourText : 'hh'}} </span> \n  <span>{{timerObj.mins}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.minuteText ? timerTextConfig.minuteText : 'mm'}}  </span> \n  <span>{{timerObj.seconds}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.secondsText ? timerTextConfig.secondsText : 'ss'}}</span>\n</div>",
                styles: [""]
            }] }
];
/** @nocollapse */
CountupTimerComponent.ctorParameters = () => [
    { type: CountupTimerService }
];
CountupTimerComponent.propDecorators = {
    startTime: [{ type: Input }],
    countUpTimerConfig: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class countDownTimerConfigModel {
}
class countDownTimerTexts {
}
/** @enum {string} */
const TimerStaus = {
    START: "START",
    PAUSE: "PAUSE",
    STOP: "STOP",
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CountdownTimerService {
    constructor() {
        this.onTimerStatusChange = new EventEmitter();
        //Init
        this.timerValue = {
            seconds: '00',
            mins: '00',
            hours: '00',
        };
        this.isTimerStart = false;
        this.totalSeconds = 0;
        this.currentOperationId = 0;
        //start timer
        this.startTimer = (/**
         * @param {?} startTime
         * @return {?}
         */
        (startTime) => {
            if (startTime) {
                /** @type {?} */
                let currentDate = new Date();
                /** @type {?} */
                let startedTime = new Date(startTime);
                this.totalSeconds = (Math.round((currentDate.getTime() - startedTime.getTime()) / 1000)) * -1;
            }
            this.isTimerStart = true;
            this.onTimerStatusChange.emit(TimerStaus.START);
            return true;
        });
        //end timer
        this.pauseTimer = (/**
         * @param {?=} startTime
         * @param {?=} endTime
         * @return {?}
         */
        (startTime, endTime) => {
            if (startTime && endTime) {
                /** @type {?} */
                let endedDate = new Date(endTime);
                /** @type {?} */
                let startedTime = new Date(startTime);
                this.totalSeconds = Math.round((endedDate.getTime() - startedTime.getTime()) / 1000);
            }
            this.isTimerStart = false;
            this.onTimerStatusChange.emit(TimerStaus.PAUSE);
            return false;
        });
        //reset Timer
        this.stopTimer = (/**
         * @return {?}
         */
        () => {
            this.isTimerStart = false;
            this.totalSeconds = 0;
            this.onTimerStatusChange.emit(TimerStaus.STOP);
        });
        //resume Timer
        this.resumeTimer = (/**
         * @return {?}
         */
        () => {
            this.isTimerStart = true;
        });
        //get timer value Obj
        this.getTimerValue = (/**
         * @return {?}
         */
        () => {
            return new Observable((/**
             * @param {?} obs
             * @return {?}
             */
            obs => {
                if (this.intervalSubscription) {
                    this.intervalSubscription.unsubscribe();
                }
                this.intervalSubscription = this.interval.subscribe((/**
                 * @param {?} int
                 * @return {?}
                 */
                int => {
                    if (this.isTimerStart && this.totalSeconds > 0) {
                        --this.totalSeconds;
                        this.timerValue.seconds = this.setTimervalue(this.totalSeconds % 60);
                        /** @type {?} */
                        let totalSecondsForMinutes = 0;
                        totalSecondsForMinutes = (Math.trunc(this.totalSeconds / 60) >= 60) ? (this.totalSeconds / 60) % 60 : this.totalSeconds / 60;
                        this.timerValue.mins = this.setTimervalue(Math.trunc(totalSecondsForMinutes));
                        this.timerValue.hours = this.setTimervalue(Math.trunc(this.totalSeconds / 3600));
                        obs.next(this.timerValue);
                        obs.complete();
                    }
                    else {
                        if (this.totalSeconds > 0) {
                            this.timerValue.seconds = this.setTimervalue(this.totalSeconds % 60);
                            /** @type {?} */
                            let totalSecondsForMinutes = 0;
                            totalSecondsForMinutes = (Math.trunc(this.totalSeconds / 60) >= 60) ? (this.totalSeconds / 60) % 60 : this.totalSeconds / 60;
                            this.timerValue.mins = this.setTimervalue(Math.trunc(totalSecondsForMinutes));
                            this.timerValue.hours = this.setTimervalue(Math.trunc(this.totalSeconds / 3600));
                        }
                        else {
                            this.timerValue.hours = "00";
                            this.timerValue.mins = "00";
                            this.timerValue.seconds = "00";
                            this.stopTimer();
                        }
                        obs.next(this.timerValue);
                        obs.complete();
                    }
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                error => {
                    obs.error(error);
                    obs.complete();
                }));
            }));
        });
        //set timer value
        this.setTimervalue = (/**
         * @param {?} val
         * @return {?}
         */
        (val) => {
            /** @type {?} */
            let valString = val + "";
            return (valString.length < 2) ? "0" + valString : valString;
        });
        this.interval = interval(1000);
    }
}
CountdownTimerService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CountdownTimerService.ctorParameters = () => [];
/** @nocollapse */ CountdownTimerService.ngInjectableDef = defineInjectable({ factory: function CountdownTimerService_Factory() { return new CountdownTimerService(); }, token: CountdownTimerService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CountdownTimerComponent {
    /**
     * @param {?} countdownTimerService
     */
    constructor(countdownTimerService) {
        this.countdownTimerService = countdownTimerService;
        this.timerObj = {};
        //get timer value
        this.getTimerValue = (/**
         * @return {?}
         */
        () => {
            this.timerSubscription = this.countdownTimerService.getTimerValue().subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => {
                this.timerObj = Object.assign(res);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                console.log(error);
                console.log('Failed to get timer value');
            }));
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.getTimerValue();
        this.timerConfig = new countDownTimerConfigModel();
        this.timerTextConfig = new countDownTimerTexts();
        this.timerConfig = this.countDownTimerConfig ? Object.assign(this.countDownTimerConfig) : null;
        this.timerTextConfig = this.countDownTimerConfig && this.countDownTimerConfig.timerTexts ? Object.assign(this.countDownTimerConfig.timerTexts) : null;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.timerSubscription.unsubscribe();
    }
}
CountdownTimerComponent.decorators = [
    { type: Component, args: [{
                selector: 'countdown-timer',
                template: "<div [class]=\"timerConfig?.timerClass ? timerConfig.timerClass : ''\">\r\n  <span>{{timerObj.hours}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.hourText ? timerTextConfig.hourText : 'hh'}} </span> \r\n  <span>{{timerObj.mins}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.minuteText ? timerTextConfig.minuteText : 'mm'}}  </span> \r\n  <span>{{timerObj.seconds}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.secondsText ? timerTextConfig.secondsText : 'ss'}}</span>\r\n</div>",
                styles: [""]
            }] }
];
/** @nocollapse */
CountdownTimerComponent.ctorParameters = () => [
    { type: CountdownTimerService }
];
CountdownTimerComponent.propDecorators = {
    startTime: [{ type: Input }],
    countDownTimerConfig: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StopWatchService {
    constructor() {
        //Init
        this.timerValue = {
            miliseconds: '00',
            seconds: '00',
            mins: '00',
            hours: '00',
        };
        this.isTimerStart = false;
        this.totalSeconds = 0;
        this.currentOperationId = 0;
        //start timer
        this.startTimer = (/**
         * @return {?}
         */
        () => {
            debugger;
            this.isTimerStart = true;
            return true;
        });
        //end timer
        this.pauseTimer = (/**
         * @param {?=} startTime
         * @param {?=} endTime
         * @return {?}
         */
        (startTime, endTime) => {
            if (startTime && endTime) {
                /** @type {?} */
                let endedDate = new Date(endTime);
                /** @type {?} */
                let startedTime = new Date(startTime);
                this.totalSeconds = Math.round((endedDate.getTime() - startedTime.getTime()) / 1000);
            }
            this.isTimerStart = false;
            return false;
        });
        //reset Timer
        this.stopTimer = (/**
         * @return {?}
         */
        () => {
            this.isTimerStart = false;
            this.totalSeconds = 0;
        });
        //resume Timer
        this.resumeTimer = (/**
         * @return {?}
         */
        () => {
            this.isTimerStart = true;
        });
        //get timer value Obj
        this.getTimerValue = (/**
         * @return {?}
         */
        () => {
            return new Observable((/**
             * @param {?} obs
             * @return {?}
             */
            obs => {
                if (this.intervalSubscription) {
                    this.intervalSubscription.unsubscribe();
                }
                this.intervalSubscription = this.interval.subscribe((/**
                 * @param {?} int
                 * @return {?}
                 */
                int => {
                    if (this.isTimerStart && this.totalSeconds > 0) {
                        --this.totalSeconds;
                        this.timerValue.seconds = this.setTimervalue(this.totalSeconds % 60);
                        /** @type {?} */
                        let totalSecondsForMinutes = 0;
                        totalSecondsForMinutes = (Math.trunc(this.totalSeconds / 60) >= 60) ? (this.totalSeconds / 60) % 60 : this.totalSeconds / 60;
                        this.timerValue.mins = this.setTimervalue(Math.trunc(totalSecondsForMinutes));
                        this.timerValue.hours = this.setTimervalue(Math.trunc(this.totalSeconds / 3600));
                        obs.next(this.timerValue);
                        obs.complete();
                    }
                    else {
                        if (this.totalSeconds > 0) {
                            this.timerValue.seconds = this.setTimervalue(this.totalSeconds % 60);
                            /** @type {?} */
                            let totalSecondsForMinutes = 0;
                            totalSecondsForMinutes = (Math.trunc(this.totalSeconds / 60) >= 60) ? (this.totalSeconds / 60) % 60 : this.totalSeconds / 60;
                            this.timerValue.mins = this.setTimervalue(Math.trunc(totalSecondsForMinutes));
                            this.timerValue.hours = this.setTimervalue(Math.trunc(this.totalSeconds / 3600));
                        }
                        else {
                            this.timerValue.hours = "00";
                            this.timerValue.mins = "00";
                            this.timerValue.seconds = "00";
                        }
                        obs.next(this.timerValue);
                        obs.complete();
                    }
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                error => {
                    obs.error(error);
                    obs.complete();
                }));
            }));
        });
        //set timer value
        this.setTimervalue = (/**
         * @param {?} val
         * @return {?}
         */
        (val) => {
            /** @type {?} */
            let valString = val + "";
            return (valString.length < 2) ? "0" + valString : valString;
        });
        this.interval = interval(10000);
    }
}
StopWatchService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
StopWatchService.ctorParameters = () => [];
/** @nocollapse */ StopWatchService.ngInjectableDef = defineInjectable({ factory: function StopWatchService_Factory() { return new StopWatchService(); }, token: StopWatchService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StopWatchComponent {
    // timerConfig: countDownTimerConfigModel;
    // timerTextConfig: countDownTimerTexts;
    /**
     * @param {?} countdownTimerService
     */
    constructor(countdownTimerService) {
        this.countdownTimerService = countdownTimerService;
        this.timerObj = {};
        //get timer value
        this.getTimerValue = (/**
         * @return {?}
         */
        () => {
            this.timerSubscription = this.countdownTimerService.getTimerValue().subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => {
                this.timerObj = Object.assign(res);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                console.log(error);
                console.log('Failed to get timer value');
            }));
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.getTimerValue();
        // this.timerConfig = new countDownTimerConfigModel();
        // this.timerTextConfig = new countDownTimerTexts();
        // this.timerConfig = this.countDownTimerConfig ? Object.assign(this.countDownTimerConfig) : null;
        // this.timerTextConfig = this.countDownTimerConfig && this.countDownTimerConfig.timerTexts ? Object.assign(this.countDownTimerConfig.timerTexts) :  null;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.timerSubscription.unsubscribe();
    }
}
StopWatchComponent.decorators = [
    { type: Component, args: [{
                selector: 'stop-watch',
                template: "<!-- <div [class]=\"timerConfig?.timerClass ? timerConfig.timerClass : ''\">\n  <span>{{timerObj.hours}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.hourText ? timerTextConfig.hourText : 'hh'}} </span> \n  <span>{{timerObj.mins}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.minuteText ? timerTextConfig.minuteText : 'mm'}}  </span> \n  <span>{{timerObj.seconds}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.secondsText ? timerTextConfig.secondsText : 'ss'}}</span>\n  <span>{{timerObj.miliseconds}}</span><span class=\"time-category\">{{timerTextConfig && timerTextConfig.milisecondsText ? timerTextConfig.milisecondsText : 'ss'}}</span>\n</div> -->",
                styles: [""]
            }] }
];
/** @nocollapse */
StopWatchComponent.ctorParameters = () => [
    { type: StopWatchService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxTimerModule {
}
NgxTimerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CountupTimerComponent,
                    CountdownTimerComponent,
                    StopWatchComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    CountupTimerComponent,
                    CountdownTimerComponent,
                    StopWatchComponent
                ],
                entryComponents: [
                    CountupTimerComponent,
                    CountdownTimerComponent,
                    StopWatchComponent
                ],
                providers: [
                    CountupTimerService,
                    CountdownTimerService,
                    StopWatchService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxTimerModule, CountupTimerComponent, CountupTimerService, countUpTimerConfigModel, timerTexts, CountdownTimerComponent, CountdownTimerService, countDownTimerConfigModel, countDownTimerTexts, TimerStaus, StopWatchComponent as ɵa, StopWatchService as ɵb };

//# sourceMappingURL=ngx-timer.js.map
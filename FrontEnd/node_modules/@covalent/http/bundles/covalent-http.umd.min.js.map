{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@covalent/http/interceptors/http.service.ts","ng://@covalent/http/actions/http.mixin.ts","ng://@covalent/http/interceptors/url-regexp-interceptor-matcher.class.ts","ng://@covalent/http/http.module.ts","ng://@covalent/http/actions/params/abstract-param.decorator.ts","ng://@covalent/http/actions/methods/abstract-method.decorator.ts","ng://@covalent/http/actions/methods/get.decorator.ts","ng://@covalent/http/actions/methods/post.decorator.ts","ng://@covalent/http/actions/methods/patch.decorator.ts","ng://@covalent/http/actions/methods/put.decorator.ts","ng://@covalent/http/actions/methods/delete.decorator.ts","ng://@covalent/http/actions/class/http.decorator.ts","ng://@covalent/http/actions/params/param.decorator.ts","ng://@covalent/http/actions/params/body.decorator.ts","ng://@covalent/http/actions/params/response.decorator.ts","ng://@covalent/http/actions/params/query-params.decorator.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__values","o","m","Symbol","iterator","i","call","next","length","value","done","__read","n","r","e","ar","push","error","defineProperty","TdInterceptorBehaviorService","_requestInterceptors","_httpInterceptorMatcher","_injector","requestInterceptorConfigs","_this","forEach","config","interceptor","get","paths","tslib_1.__extends","HttpClient","TdHttpService","request","first","url","options","interceptors","_interceptorBehavior","requestInterceptors","filter","mapping","httpInterceptorMatcher","matches","map","_setupRequest","method","_requestResolve","Observable","subscriber","_handleResponseResolve","_super","handleOptions","obs","reverse","handleResponse","_handler","getInjector","inject","INJECTOR","InternalHttpService","Error","mixinHttp","base","httpInject","HttpInternalClass","args","_i","arguments","apply","__spread","concat","injectArgs","types","injector","arg","isArray","type","undefined","flags","InjectFlags","Default","j","meta","Optional","ngMetadataName","SkipSelf","Self","Inject","token","ɵReflectionCapabilities","parameters","buildConfig","class_1","basePath","replace","_baseUrl","http","baseUrl","_baseHeaders","baseHeaders","HttpHeaders","_defaultObserve","defaultObserve","_defaultResponseType","defaultResponseType","buildHeaders","headersObj","keys","key","buildRequest","_buildRequest","responseType","observe","headers","headers_1","set","Injectable","providedIn","Injector","TdURLRegExpInterceptorMatcher","path","RegExp","test","HTTP_CONFIG","InjectionToken","httpFactory","handler","HTTP_INTERCEPTOR_PROVIDER","provide","useFactory","deps","HttpHandler","CovalentHttpModule","forRoot","ngModule","providers","useValue","NgModule","imports","HttpClientModule","_internalHttpService","tdHttpRESTParam","TdAbstractParam","param","target","propertyKey","parameterIndex","Reflect","getOwnMetadata","index","defineMetadata","NOOP_HTTP","of","parseParams","source","queryParams","HttpParams","getAll","append","TdAbstractMethod","propertyName","descriptor","wrappedFunction","replacedPath","newArgs","body","parameters_1","tslib_1.__values","parameters_1_1","parameter","qParams","params","assign","parameters_2","parameters_2_1","response","console","TdGET","TdPOST","TdPATCH","TdPUT","TdDELETE","TdHttp","TdHttpClient","class_2","TdParam","TdBody","TdResponse","TdQueryParams"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Type, Injector } from '@angular/core';\nimport { HttpClient, HttpHandler, HttpResponse, HttpRequest, HttpHeaders, HttpParams } from '@angular/common/http';\n\nimport { Observable, Subscriber } from 'rxjs';\n\nimport { ITdHttpInterceptor } from './http-interceptor.interface';\nimport { ITdHttpInterceptorMatcher } from './http-interceptor-matcher.interface';\nimport { ITdHttpInterceptorMapping } from './http-interceptor-mapping.interface';\n\nimport { ITdHttpRESTOptionsWithBody } from '../http.interfaces';\n\nexport interface ITdHttpInterceptorConfig {\n  interceptor: Type<any>;\n  paths: string[];\n}\n\nexport class TdInterceptorBehaviorService {\n  private _requestInterceptors: ITdHttpInterceptorMapping[] = [];\n\n  get requestInterceptors(): ITdHttpInterceptorMapping[] {\n    return this._requestInterceptors;\n  }\n\n  get httpInterceptorMatcher(): ITdHttpInterceptorMatcher {\n    return this._httpInterceptorMatcher;\n  }\n\n  constructor(private _injector: Injector,\n              private _httpInterceptorMatcher: ITdHttpInterceptorMatcher,\n              requestInterceptorConfigs: ITdHttpInterceptorConfig[]) {\n    requestInterceptorConfigs.forEach((config: ITdHttpInterceptorConfig) => {\n      this._requestInterceptors.push({\n        interceptor: <ITdHttpInterceptor>_injector.get(config.interceptor),\n        paths: config.paths,\n      });\n    });\n  }\n}\n\nexport class TdHttpService extends HttpClient {\n\n  constructor(private _handler: HttpHandler,\n              private _interceptorBehavior: TdInterceptorBehaviorService) {\n    super(_handler);\n  }\n\n  request(first: string|HttpRequest<any>, url?: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body' | 'events' | 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    let interceptors: ITdHttpInterceptor[] = this._interceptorBehavior.requestInterceptors.filter((mapping: ITdHttpInterceptorMapping) => {\n      return this._interceptorBehavior.httpInterceptorMatcher.matches({url: url}, mapping);\n    }).map((mapping: ITdHttpInterceptorMapping) => {\n      return mapping.interceptor;\n    });\n    return this._setupRequest(first, url, options, interceptors);\n  }\n\n  private _setupRequest(method: string|HttpRequest<any>,\n                        url: string,\n                        options: ITdHttpRESTOptionsWithBody,\n                        interceptors: ITdHttpInterceptor[]): Observable<HttpResponse<any>> {\n    try {\n      options = this._requestResolve(options, interceptors);\n    } catch (e) {\n      return new Observable<any>((subscriber: Subscriber<any>) => {\n        subscriber.error(e);\n      });\n    }\n    return this._handleResponseResolve(super.request(<any>method, url, options), interceptors);\n  }\n\n  private _requestResolve(options: ITdHttpRESTOptionsWithBody, interceptors: ITdHttpInterceptor[]): ITdHttpRESTOptionsWithBody {\n    interceptors.forEach((interceptor: ITdHttpInterceptor) => {\n      if (interceptor.handleOptions) {\n        options = interceptor.handleOptions(options);\n      }\n    });\n    return options;\n  }\n\n  private _handleResponseResolve(obs: Observable<any>, interceptors: ITdHttpInterceptor[]): Observable<any> {\n    interceptors.reverse().forEach((interceptor: ITdHttpInterceptor) => {\n      if (interceptor.handleResponse) {\n        obs = interceptor.handleResponse(obs);\n      }\n    });\n    return obs;\n  }\n}\n","import { Type, Injectable, Injector, ÉµReflectionCapabilities, InjectFlags, Optional,\n  SkipSelf, Self, Inject, InjectionToken, inject, INJECTOR } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { TdHttpService } from '../interceptors/http.service';\n\nimport { Observable } from 'rxjs';\n\nimport { ITdHttpRESTOptions, ITdHttpRESTOptionsWithBody, TdHttpRESTResponseType, TdHttpRESTObserve, TdHttpMethod } from '../http.interfaces';\n\nexport interface ITdHttpRESTConfig {\n  baseHeaders?: HttpHeaders;\n  baseUrl: string;\n  defaultObserve?: TdHttpRESTObserve;\n  defaultResponseType?: TdHttpRESTResponseType;\n}\n\ntype Constructor<T> = new (...args: any[]) => T;\n\n/**\n * DO NOT MODIFY\n * Taken from angular since they dont expose this function\n * This is used internally to inject services from the constructor of the base service using the mixinHttp\n * @internal\n */\nfunction injectArgs(types: (Type<any>| InjectionToken<any>| any[])[], injector: Injector): any[] {\n  const args: any[] = [];\n  for (let i: number = 0; i < types.length; i++) {\n    const arg: any = types[i];\n    if (arg) {\n      if (Array.isArray(arg)) {\n        if (arg.length === 0) {\n          throw new Error('Arguments array must have arguments.');\n        }\n        let type: Type<any>|undefined = undefined;\n        let flags: InjectFlags = InjectFlags.Default;\n\n        for (let j: number = 0; j < arg.length; j++) {\n          const meta: any = arg[j];\n          if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n            /* tslint:disable */\n            flags |= InjectFlags.Optional;\n          } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n            flags |= InjectFlags.SkipSelf;\n          } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n            flags |= InjectFlags.Self;\n          } else if (meta instanceof Inject) {\n            type = meta.token;\n          } else {\n            type = meta;\n          }\n          /* tslint:enable */\n        }\n\n        args.push(injector.get(type !, flags));\n      } else {\n        args.push(injector.get(arg));\n      }\n    }\n  }\n  return args;\n}\n\nexport function getInjector(): Injector {\n  try {\n    return inject(INJECTOR);\n  } catch (e) {\n    if (!InternalHttpService._injector) {\n      throw new Error('Please add CovalentHttpModule into your imports.');\n    }\n    return InternalHttpService._injector;\n  }\n}\n\n/** \n * Mixin to augment a service with http helpers.\n * @internal\n */\nexport function mixinHttp(base: any,\n                          config: ITdHttpRESTConfig,\n                          httpInject: Type<HttpClient | TdHttpService> = TdHttpService): Constructor<any> {\n  /**\n   * Internal class used to get an instance of Injector for internal usage plus also\n   * a way to inject services from the constructor of the underlying service\n   * @internal\n   */\n  abstract class HttpInternalClass extends base {\n    constructor(...args: any[]) {\n      super(...(args && args.length ? args : injectArgs(new ÉµReflectionCapabilities().parameters(base), getInjector())));\n      this._injector = getInjector();\n      this.buildConfig();\n    }\n    abstract buildConfig(): void;\n  }\n  /**\n   * Actuall class being returned with all the hooks for http usage\n   * @internal\n   */\n  return class extends HttpInternalClass {\n    private _baseUrl: string;\n    get baseUrl(): string {\n      return (typeof(this.basePath) === 'string' ?\n        this.basePath.replace(/\\/$/, '') : '') + this._baseUrl;\n    }\n    private _baseHeaders: HttpHeaders;\n    private _defaultObserve?: TdHttpRESTObserve;\n    private _defaultResponseType?: TdHttpRESTResponseType;\n\n    http: HttpClient | TdHttpService;\n\n    /**\n     * Method used to setup the configuration parameters and get an instance of the http service\n     */\n    buildConfig(): void {\n      this.http = this._injector.get(httpInject);\n      this._baseUrl = config && config.baseUrl ? config.baseUrl.replace(/\\/$/, '') : '';\n      this._baseHeaders = config && config.baseHeaders ? config.baseHeaders : new HttpHeaders();\n      this._defaultObserve = config && config.defaultObserve ? config.defaultObserve : 'body';\n      this._defaultResponseType = config && config.defaultResponseType ? config.defaultResponseType : 'json';\n    }\n\n    /**\n     * Method used to build the default headers using the base headers\n     */\n    buildHeaders(): HttpHeaders {\n      let headersObj: {[key: string]: any} = {};\n      this._baseHeaders.keys().forEach((key: any) => {\n        headersObj[key] = this._baseHeaders.get(key);\n      });\n      return new HttpHeaders(headersObj);\n    }\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: 'POST' | 'PUT' | 'PATCH', url: string, options?: ITdHttpRESTOptionsWithBody): Observable<HttpResponse>;\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: 'GET' | 'DELETE', url: string, options?: ITdHttpRESTOptions): Observable<HttpResponse>;\n    /* tslint:disable-next-line */\n    buildRequest<HttpResponse>(method: TdHttpMethod, url: string, options?: ITdHttpRESTOptionsWithBody): Observable<HttpResponse> {\n      return this._buildRequest(method, url, options);\n    }\n\n    /**\n     * Method used to build the request depending on the `http` service and TdHttpMethod\n     */\n    private _buildRequest(method: TdHttpMethod, url: string, options: ITdHttpRESTOptionsWithBody = {}): Observable<any> {\n      if (!options.responseType) {\n        options.responseType = this._defaultResponseType;\n      }\n      if (!options.observe) {\n        options.observe = this._defaultObserve;\n      }\n      if (!options.headers) {\n        options.headers = this.buildHeaders();\n      } else {\n        let headers: HttpHeaders = this.buildHeaders();\n        if (options.headers instanceof HttpHeaders) {\n          (<HttpHeaders>options.headers).keys().forEach((key: any) => {\n            headers = headers.set(key, (<HttpHeaders>options.headers).get(key));\n          });\n        } else {\n          for (let key in options.headers) {\n            headers = headers.set(key, <any>options.headers[key]);\n          }\n        }\n        options.headers = headers;\n      }\n      return (<TdHttpService>this.http).request(method, url, options);\n    }\n  };\n}\n\n/** \n * @internal\n * WORKAROUND until Ivy Renderer is ready\n */\n@Injectable({providedIn: 'root'})\nexport class InternalHttpService {\n\n  static _injector: Injector = undefined;\n\n  constructor(_injector: Injector) {\n    InternalHttpService._injector = _injector;\n  }\n}\n","import { ITdHttpInterceptorMapping } from './http-interceptor-mapping.interface';\nimport { ITdHttpInterceptorMatcher } from './http-interceptor-matcher.interface';\n\n/**\n * Concrete implementation for http interceptor matchers.\n * This implementation uses regex to check mapping paths vs request url.\n */\nexport class TdURLRegExpInterceptorMatcher implements ITdHttpInterceptorMatcher {\n\n  matches(options: {url: string}, mapping: ITdHttpInterceptorMapping): boolean {\n    return mapping.paths.filter((path: string) => {\n      path = path.replace(/\\*\\*/gi, '<>')\n                .replace(/\\*/gi, '[a-zA-Z0-9\\\\-_]+')\n                .replace(/<>/gi, '[a-zA-Z0-9\\\\-_\\/]*');\n      if (path) {\n        path += '(\\\\?{1}.*)?$';\n        return new RegExp(path).test(options.url);\n      }\n      return false;\n    }).length > 0;\n  }\n\n}\n","import { NgModule, ModuleWithProviders, Injector, InjectionToken, Provider } from '@angular/core';\nimport { HttpClientModule, HttpHandler } from '@angular/common/http';\n\nimport { InternalHttpService } from './actions/http.mixin';\n\nimport { TdHttpService, TdInterceptorBehaviorService, ITdHttpInterceptorConfig } from './interceptors/http.service';\nimport { TdURLRegExpInterceptorMatcher } from './interceptors/url-regexp-interceptor-matcher.class';\n\nexport const HTTP_CONFIG: InjectionToken<HttpConfig> = new InjectionToken<HttpConfig>('HTTP_CONFIG');\n\nexport type HttpConfig = {interceptors: ITdHttpInterceptorConfig[]};\n\nexport function httpFactory(handler: HttpHandler, injector: Injector, config: HttpConfig): TdHttpService {\n  return new TdHttpService(\n              handler,\n              new TdInterceptorBehaviorService(injector, new TdURLRegExpInterceptorMatcher(), config.interceptors),\n            );\n}\n\nexport const HTTP_INTERCEPTOR_PROVIDER: Provider = {\n  provide: TdHttpService,\n  useFactory: httpFactory,\n  deps: [HttpHandler, Injector, HTTP_CONFIG],\n};\n\n@NgModule({\n  imports: [\n    HttpClientModule,\n  ],\n  providers: [\n    InternalHttpService,\n  ],\n})\nexport class CovalentHttpModule {\n\n  constructor(private _internalHttpService: InternalHttpService) {}\n\n  static forRoot(config: HttpConfig = {interceptors: []}): ModuleWithProviders {\n    return {\n      ngModule: CovalentHttpModule,\n      providers: [{\n          provide: HTTP_CONFIG,\n          useValue: config,\n        },\n        HTTP_INTERCEPTOR_PROVIDER,\n      ],\n    };\n  }\n}\n","declare const Reflect: any;\nexport type TdParamType = 'param' | 'response' | 'body' | 'queryParams';\n\nexport const tdHttpRESTParam: Symbol = Symbol('TdHttpRESTParam');\n\n/**\n * Abstract implementation of the http param decorator\n * @internal\n */\nexport function TdAbstractParam(type: TdParamType, param?: string): Function {\n  return function (target: Object, propertyKey: string | symbol, parameterIndex: number): void {\n    let parameters: { index: number, param: string, type: TdParamType }[] = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyKey) || [];\n    parameters.push({\n      index: parameterIndex,\n      param: param,\n      type: type,\n    });\n    Reflect.defineMetadata(tdHttpRESTParam, parameters, target, propertyKey);\n  };\n}\n","import { HttpParams } from '@angular/common/http';\n\nimport { TdHttpMethod, ITdHttpRESTOptions, ITdHttpRESTOptionsWithBody } from '../../http.interfaces';\nimport { TdParamType, tdHttpRESTParam } from '../params/abstract-param.decorator';\n\nimport { Observable, of } from 'rxjs';\n\ndeclare const Reflect: any;\n\nexport const NOOP_HTTP: Observable<any> = of(undefined);\n\n/**\n * Method used to copy parameters from an array or HttpParams object\n * into a centrilized HttpParams object\n * @internal\n */\nexport function parseParams(target: HttpParams, source: HttpParams | {[key: string]: string | string[]}): HttpParams {\n  let queryParams: HttpParams = target;\n  if (source instanceof HttpParams) {\n    source.keys().forEach((key: string) => {\n      // skip if value is undefined\n      if ((<HttpParams>source).get(key) !== undefined) {\n        (<HttpParams>source).getAll(key).forEach((value: string, index: number) => {\n          if (index === 0) {\n            queryParams = queryParams.set(key, value);\n          } else {\n            queryParams = queryParams.append(key, value);\n          }\n        });\n      }\n    });\n  } else {\n    for (let key in source) {\n      // skip if value is undefined\n      if (<any>source[key] !== undefined) {\n        if (source[key] instanceof Array) {\n          (<string[]>source[key]).forEach((value: string, index: number) => {\n            if (index === 0) {\n              queryParams = queryParams.set(key, value);\n            } else {\n              queryParams = queryParams.append(key, value);\n            }\n          });\n        } else {\n          queryParams = queryParams.set(key, <any>source[key]);\n        }\n      }\n    }\n  }\n  return queryParams;\n}\n\n/**\n * Abstract implementation of the http method decorator\n * @internal\n */\nexport function TdAbstractMethod(config: {\n  method: TdHttpMethod,\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return function (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>): any {\n    let wrappedFunction: Function = descriptor.value;\n    // replace method call with our own and proxy it\n    descriptor.value = function (): any {\n      try {\n        let replacedPath: string = config.path;\n        let parameters: { index: number, param: string, type: TdParamType }[] = Reflect.getOwnMetadata(tdHttpRESTParam, target, propertyName);\n        let newArgs: any[] = [];\n        let body: any;\n        let queryParams: HttpParams = new HttpParams();\n        if (parameters) {\n          // map parameters and see which type they are to act on them\n          for (let parameter of parameters) {\n            if (parameter.type === 'param') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              replacedPath = replacedPath.replace(':' + parameter.param, arguments[parameter.index]);\n            } else if (parameter.type === 'body') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              body = arguments[parameter.index];\n            } else if (parameter.type === 'queryParams') {\n              newArgs[parameter.index] = arguments[parameter.index];\n              let qParams: HttpParams | {[key: string]: string | string[]} = arguments[parameter.index];\n              if (config.options && config.options.params) {\n                queryParams = parseParams(queryParams, config.options.params);\n              }\n              if (qParams) {\n                queryParams = parseParams(queryParams, qParams);\n              }\n            }\n          }\n        }\n        // tslint:disable-next-line\n        let url: string = this.baseUrl + replacedPath;\n        let options: ITdHttpRESTOptionsWithBody = Object.assign({}, config.options, {\n          body: body,\n          params: queryParams,\n        });\n        // tslint:disable-next-line\n        let request: any = this.buildRequest(config.method, url, options);\n        if (parameters) {\n          // see which one was the response parameter so we can set the request observable\n          for (let parameter of parameters) {\n            if (parameter.type === 'response') {\n              newArgs[parameter.index] = request;\n            }\n          }\n        }\n        // tslint:disable-next-line\n        let response: any = wrappedFunction.apply(this, newArgs);\n        // if the response is NOOP_HTTP or undefined, then we return the request as it is\n        // else we return the response from the inner function\n        if (response === NOOP_HTTP || response === undefined) {\n          return request;\n        } else {\n          return response;\n        }\n      } catch (error) {\n        // tslint:disable-next-line\n        console.error(error);\n      }\n    };\n  };\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds GET request capabilities to a method\n */\nexport function TdGET(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'GET',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds POST request capabilities to a method\n */\nexport function TdPOST(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'POST',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds PATCH request capabilities to a method\n */\nexport function TdPATCH(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'PATCH',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds PUT request capabilities to a method\n */\nexport function TdPUT(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'PUT',\n  }, config));\n}\n","import { ITdHttpRESTOptions } from '../../';\nimport { TdAbstractMethod } from './abstract-method.decorator';\n\n/**\n * Decorator that adds DELETE request capabilities to a method\n */\nexport function TdDELETE(config: {\n  path: string,\n  options?: ITdHttpRESTOptions,\n}): Function {\n  return TdAbstractMethod(<any>Object.assign({\n    method: 'DELETE',\n  }, config));\n}\n","import { HttpClient } from '@angular/common/http';\n\nimport { mixinHttp, ITdHttpRESTConfig } from '../http.mixin';\n\nimport { TdHttpService } from '../../interceptors/http.service';\n\n/**\n * Decorator used to give a service http capabilities using TdHttpService\n */\nexport function TdHttp(config: ITdHttpRESTConfig): Function {\n  return function <T extends { new(...args: any[]): {} }>(constructor: any): any {\n    return class extends mixinHttp(constructor, config, TdHttpService) {\n     \n    };\n  };\n}\n\n/**\n * Decorator used to give a service http capabilities using HttpClient\n */\nexport function TdHttpClient(config: ITdHttpRESTConfig): Function {\n  return function <T extends { new(...args: any[]): {} }>(constructor: any): any {\n    return class extends mixinHttp(constructor, config, HttpClient) {\n     \n    };\n  };\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is an http parameter in a method\n */\nexport function TdParam(param: string): Function {\n  return TdAbstractParam('param', param);\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http body in a method\n */\nexport function TdBody(): Function {\n  return TdAbstractParam('body');\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http response in a method\n */\nexport function TdResponse(): Function {\n  return TdAbstractParam('response');\n}\n","import { TdAbstractParam } from './abstract-param.decorator';\n\n/**\n * Decorator that is used to define which parameter is the http query parameters in a method\n */\nexport function TdQueryParams(): Function {\n  return TdAbstractParam('queryParams');\n}\n"]}